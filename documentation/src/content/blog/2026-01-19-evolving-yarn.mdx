---
slug: 2025-11-11-evolving-yarn
title: Evolving Yarn
author: arcanis
---

I’m excited to announce the next steps Yarn will be taking to redefine what “state of the art” means when it comes to JavaScript package managers.

{/* truncate */}

Yarn always cared about three things: correctness, developer experience, and performances. Being at the top of the game on all three axes can be challenging, but we believe you shouldn’t expect less from your package manager, the foundation of your project. While satisfied with the correctness and developer experience aspects, it felt to me these past years that Yarn was struggling on the performance side of things - especially with massive monorepos, hosting thousands of workspaces.

Almost ten years after the first public release of Yarn, now is a great time to tell you more about our plans to port Yarn to Rust in the next 6-8 months, thanks to a project that started more than a year ago and that we now feel is ready to receive your attention. This will lead to higher responsiveness and lower memory footprints, which will in turn let us build features we couldn’t efficiently pull off until now.

## How much faster?

Keep in mind that while performances are a significant part of why we did this rewrite, we first focused on the compatibility aspect. Many low hanging fruits remain, and we’re excited to work with the JavaScript / Rust tooling community to increase the difference even further.

<div class="w-full overflow-auto">
  <table class="table-fixed [&_th,&_td]:min-w-auto">
    <colgroup>
      <col style="width: calc(100% - 600px); min-width: 200px"/>
      <col style="width: 200px"/>
      <col style="width: 200px"/>
      <col style="width: 200px"/>
    </colgroup>
    <thead>
      <tr>
        <th>Test</th>
        <th>Before</th>
        <th>After</th>
        <th>Pnpm</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th colspan="4">Next.js - few but heavy dependencies</th>
      </tr>
      <tr>
        <td>Cold cache</td>
        <td>4.1s</td>
        <td>2.5s</td>
        <td>3.0s</td>
      </tr>
      <tr>
        <td>Warm cache</td>
        <td>577ms</td>
        <td>184ms</td>
        <td>686ms</td>
      </tr>
      <tr>
        <th colspan="4">Gatsby - lots of small dependencies</th>
      </tr>
      <tr>
        <td>Cold cache</td>
        <td>19.8s</td>
        <td>11.7s</td>
        <td>13.1s</td>
      </tr>
      <tr>
        <td>Warm cache</td>
        <td>1.7s</td>
        <td>0.3s</td>
        <td>1.9s</td>
      </tr>
    </tbody>
  </table>
</div>

*(more benchmarks are available here; we’re also setting up a new benchmark on massive megarepos, but those don’t run on other package managers yet)*

More than just raw performances, those numbers also unlock new opportunities. While some of them are still ideas, others are being implemented already - see for example the lazy install feature described below.

## New features

While we’re focused on completing the rewrite before looking at new features, some were foundational enough that we felt the need to implement them as part of the MVP.

### Yarn Switch

If you’re familiar with the Node.js ecosystem you may have heard about Corepack before. Corepack was an experimental project built in tandem with Node.js core contributors that intended to provide a way to manage package manager versions across projects. While package managers all lock dependencies nowadays, they don’t always support locking their own version. Corepack was solving this need, but the Node.js ultimately declined to pursue the experiment further.

Consequently we developed our own replacement for Corepack: Yarn Switch. Yarn Switch is the binary that will get installed on your machine when running the Yarn install script. When run it'll read the `packageManager` field from your project and transparently forward the command to the appropriate Yarn version. You can see it as a rustup / nvm equivalent, but for Yarn.

For more details about Yarn Switch, check out its dedicated documentation.

### Lazy Installs

Yarn has included for a while now the ability to check-in your install artifacts in your repository so you could omit running installs when switching branches as everything would get updated along with the `git checkout` command (aka Zero Installs). This process worked well enough but had some drawbacks, mostly related to repository size on massive megarepos.

Starting from Yarn 6.x we’ll provide a new default mode called Lazy Installs. Under this feature is a very simple behaviour: running most Yarn commands - including `yarn run` - will lead Yarn to silently perform an install when it sees the install artifacts aren’t up-to-date compared to the package.json files.

Thanks to being a native implementation this feature has a very low overhead in the happy path, and we think it’ll provide most of the benefits of Zero Installs without the drawbacks.

## Versioning roadmap

Our current release of Yarn is 4.12. We plan the JS codebase to continue into the Yarn 5.x series, which will be released in a couple of months as a stepping stone and will include some of the deprecations introduced in the Rust-based Yarn 6.x series.

The first Yarn 6.x stable release will be published once the Rust implementation has reached sufficient parity with the current Yarn releases, which I wouldn’t expect until at least Q3 2026. Once that happens, Yarn 5.x will enter LTS status: the codebase will receive critical bugfixes for about 30 months while active development will shift to the Rust codebase.

It should be noted that backward compatibility has been a primary concern of ours when approaching this project. As a result we’re using the exact same testsuite to validate the behaviour of Yarn 6.x compared to its predecessors, to the point where experimental releases of Yarn 6.x have already been successfully deployed in production at Datadog with minimal breaking changes.

## Next steps

Yarn 6.x is still months away, and important features remain to tackle:

- Windows support
- Interactive commands
- Collaboration with third-party tools parsing the lockfile manually
- Wrapping up the last standing failing tests

This work is ongoing, and we’re eager to engage with the community to release a tool that we think will redefine once more what JavaScript developers come to expect from their package managers.
