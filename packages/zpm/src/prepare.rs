use arca::Path;
use bincode::{Decode, Encode};
use itertools::Itertools;

use crate::{error::Error, primitives::Locator, script::ScriptEnvironment};

#[derive(Clone, Default, Debug, Decode, Encode, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PrepareParams {
    pub cwd: Option<String>,
    pub workspace: Option<String>,
}

#[derive(Debug)]
enum PackageManager {
    Npm,
    Pnpm,

    // Admittedly we perhaps change the `yarn pack` interface a little too often
    YarnClassic,
    YarnModern,
    YarnZpm,
}

pub async fn prepare_project(_locator: &Locator, folder_path: &Path, params: &PrepareParams) -> Result<Vec<u8>, Error> {
    let package_manager = get_package_manager(folder_path)?;

    match package_manager {
        PackageManager::Npm => prepare_npm_project(folder_path).await,
        PackageManager::Pnpm => prepare_pnpm_project(folder_path, params).await,
        PackageManager::YarnClassic => prepare_yarn_zpm_project(folder_path, params).await,
        PackageManager::YarnModern => prepare_yarn_modern_project(folder_path, params).await,
        PackageManager::YarnZpm => prepare_yarn_zpm_project(folder_path, params).await,
    }
}

fn get_package_manager(folder_path: &Path) -> Result<PackageManager, Error> {
    if folder_path.with_join_str("package-lock.json").fs_exists() {
        return Ok(PackageManager::Npm);
    }

    let yarn_lock_path = folder_path
        .with_join_str("yarn.lock")
        .fs_read_text();

    if let Ok(yarn_lock) = yarn_lock_path {
        if yarn_lock.starts_with("{") {
            return Ok(PackageManager::YarnZpm);
        } else if yarn_lock.starts_with("# This file is generated by running \"yarn install\" inside your project.") {
            return Ok(PackageManager::YarnModern);
        } else {
            return Ok(PackageManager::YarnClassic);
        }
    } else if let Err(err) = yarn_lock_path {
        if err.kind() != std::io::ErrorKind::NotFound {
            return Err(err.into());
        }
    }

    if folder_path.with_join_str("pnpm-lock.yaml").fs_exists() {
        return Ok(PackageManager::Pnpm);
    }

    return Ok(PackageManager::YarnZpm);
}

async fn prepare_npm_project(folder_path: &Path) -> Result<Vec<u8>, Error> {
    ScriptEnvironment::new()
        .with_cwd(folder_path.clone())

        // Otherwise npm won't properly set the user agent, using the Yarn one instead
        .delete_env_variable("npm_config_user_agent")

        // Remove environment variables that limit the install to just production dependencies
        .delete_env_variable("npm_config_production")
        .delete_env_variable("NPM_CONFIG_PRODUCTION")
        .delete_env_variable("NODE_ENV")

        .run_exec("npm", vec!["install", "--legacy-peer-deps"])
        .await
        .ok()?;

    let pack_result = ScriptEnvironment::new()
        .with_cwd(folder_path.clone())
        .run_exec("npm", vec!["pack", "--silent"])
        .await
        .ok()?;

    let stdout = &pack_result.output().stdout;

    let last_line_index = stdout.iter()
        .enumerate()
        .rev()
        .skip(1)
        .find_position(|(_, c)| **c == b'\n')
        .map(|(_, (i, _))| i)
        .unwrap();

    let last_line
        = &stdout[last_line_index + 1..stdout.len() - 1];

    let pack_file
        = String::from_utf8(last_line.to_vec())?;

    let pack_tgz = folder_path
        .with_join_str(pack_file)
        .fs_read()?;

    Ok(pack_tgz)
}

async fn prepare_yarn_modern_project(folder_path: &Path, params: &PrepareParams) -> Result<Vec<u8>, Error> {
    let pack_path = folder_path
        .with_join_str("package.tgz");

    let pack_args = match &params.workspace {
        Some(workspace_name) =>
            vec!["workspace", workspace_name.as_str(), "pack", "--install-if-needed", "--filename", pack_path.as_str()],
        None =>
            vec!["pack", "--install-if-needed", "--filename", pack_path.as_str()],
    };

    // If a lockfile doesn't exist we create a empty one to
    // prevent the project root detection from thinking it's in an
    // undeclared workspace when the user has a lockfile in their home
    // directory on Windows
    let lockfile_path = folder_path
        .with_join_str("yarn.lock");

    if !lockfile_path.fs_exists() {
        lockfile_path.fs_write(b"")?;
    }

    ScriptEnvironment::new()
        .with_cwd(folder_path.clone())

        // We enable inline builds, because nobody wants to
        // read a logfile telling them to open another logfile
        .with_env_variable("YARN_ENABLE_INLINE_BUILDS", "1")

        .run_exec("yarn", pack_args)
        .await
        .ok()?;

    let pack_tgz = pack_path
        .fs_read()?;

    Ok(pack_tgz)
}

async fn prepare_pnpm_project(folder_path: &Path, _params: &PrepareParams) -> Result<Vec<u8>, Error> {
    ScriptEnvironment::new()
        .with_cwd(folder_path.clone())
        .run_exec("pnpm", vec!["install"])
        .await
        .ok()?;

    let pack_result = ScriptEnvironment::new()
        .with_cwd(folder_path.clone())
        .run_exec("pnpm", vec!["pack"])
        .await
        .ok()?;

    let pack_file
        = String::from_utf8(pack_result.output().stdout.clone())?;

    let pack_tgz = folder_path
        .with_join_str(pack_file.trim())
        .fs_read()?;

    Ok(pack_tgz)
}

async fn prepare_yarn_zpm_project(folder_path: &Path, params: &PrepareParams) -> Result<Vec<u8>, Error> {
    let archive_path = folder_path
        .with_join_str("archive.tgz");

    ScriptEnvironment::new()
        .with_cwd(folder_path.clone())
        .run_exec("yarn", vec!["install"])
        .await
        .ok()?;

    let mut pack_args = vec![];

    if let Some(workspace) = &params.workspace {
        pack_args.push("workspace");
        pack_args.push(workspace.as_str());
    }

    pack_args.push("pack");
    pack_args.push("--filename");
    pack_args.push(archive_path.as_str());

    ScriptEnvironment::new()
        .with_cwd(folder_path.clone())
        .run_exec("yarn", pack_args)
        .await
        .ok()?;

    let pack_tgz = archive_path
        .fs_read()?;

    Ok(pack_tgz)
}
