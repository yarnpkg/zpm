use std::str::FromStr;

use itertools::Itertools;
use zpm_utils::{Path, ToFileString};
use bincode::{Decode, Encode};

use crate::{error::Error, primitives::Locator, script::ScriptEnvironment};

#[derive(Clone, Default, Debug, Decode, Encode, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PrepareParams {
    pub cwd: Option<String>,
    pub workspace: Option<String>,
}

#[derive(Debug)]
enum PackageManager {
    Npm,
    Pnpm,

    // Admittedly we perhaps change the `yarn pack` interface a little too often
    YarnClassic,
    YarnModern,
    YarnZpm,
}

pub async fn prepare_project(_locator: &Locator, folder_path: &Path, params: &PrepareParams) -> Result<Vec<u8>, Error> {
    let package_manager = get_package_manager(folder_path)?;

    match package_manager {
        PackageManager::Npm => prepare_npm_project(folder_path, params).await,
        PackageManager::Pnpm => prepare_pnpm_project(folder_path, params).await,
        PackageManager::YarnClassic => prepare_yarn_classic_project(folder_path, params).await,
        PackageManager::YarnModern => prepare_yarn_modern_project(folder_path, params).await,
        PackageManager::YarnZpm => prepare_yarn_zpm_project(folder_path, params).await,
    }
}

fn get_package_manager(folder_path: &Path) -> Result<PackageManager, Error> {
    if folder_path.with_join_str("package-lock.json").fs_exists() {
        return Ok(PackageManager::Npm);
    }

    let yarn_lock_path = folder_path
        .with_join_str("yarn.lock")
        .fs_read_text();

    if let Ok(yarn_lock) = yarn_lock_path {
        if yarn_lock.starts_with("{") {
            return Ok(PackageManager::YarnZpm);
        } else if yarn_lock.starts_with("# This file is generated by running \"yarn install\" inside your project.") {
            return Ok(PackageManager::YarnModern);
        } else {
            return Ok(PackageManager::YarnClassic);
        }
    } else if let Err(err) = yarn_lock_path {
        if err.io_kind() != Some(std::io::ErrorKind::NotFound) {
            return Err(err.into());
        }
    }

    if folder_path.with_join_str("pnpm-lock.yaml").fs_exists() {
        return Ok(PackageManager::Pnpm);
    }

    if folder_path.with_join_str("package-lock.json").fs_exists() {
        return Ok(PackageManager::Npm);
    }

    Ok(PackageManager::YarnZpm)
}

async fn prepare_npm_project(folder_path: &Path, params: &PrepareParams) -> Result<Vec<u8>, Error> {
    if params.workspace.is_some() {
        // We run "npm version" and check it returns >=7.x

        let version_result = ScriptEnvironment::new()?
            .with_cwd(folder_path.clone())
            .run_exec("npm", vec!["--version"])
            .await
            .ok()?;

        let version_stdout
            = String::from_utf8(version_result.output().stdout.trim_ascii().to_vec())?;

        let version
            = zpm_semver::Version::from_str(&version_stdout)
               .expect("Expected a valid version");

        if version.major < 7 {
            return Err(Error::UnsupportedNpmWorkspaces(version));
        }
    }

    ScriptEnvironment::new()?
        .with_cwd(folder_path.clone())

        // Otherwise npm won't properly set the user agent, using the Yarn one instead
        .delete_env_variable("npm_config_user_agent")

        // Remove environment variables that limit the install to just production dependencies
        .delete_env_variable("npm_config_production")
        .delete_env_variable("NPM_CONFIG_PRODUCTION")
        .delete_env_variable("NODE_ENV")

        // We can't use `npm ci` because some projects don't have npm
        // lockfiles that are up-to-date. Hopefully npm won't decide
        // to change the versions randomly.
        .run_exec("npm", vec!["install", "--legacy-peer-deps"])
        .await
        .ok()?;

    let pack_args = match &params.workspace {
        Some(workspace) => vec!["pack", "--silent", "--workspace", workspace],
        None => vec!["pack", "--silent"],
    };

    let pack_result = ScriptEnvironment::new()?
        .with_cwd(folder_path.clone())
        .run_exec("npm", pack_args)
        .await
        .ok()?;

    let stdout = &pack_result.output().stdout;

    // We retrieve the last line of the output; it's the name of the pack file
    let first_char_index = stdout.iter()
        .enumerate()
        .rev()
        .skip(1)
        .find_position(|(_, c)| **c == b'\n')
        .map(|(_, (i, _))| i + 1)
        .unwrap_or(0);

    let last_line
        = &stdout[first_char_index..stdout.len() - 1];

    let pack_file
        = String::from_utf8(last_line.to_vec())?;

    let pack_tgz = folder_path
        .with_join_str(pack_file)
        .fs_read()?;

    Ok(pack_tgz)
}

async fn prepare_yarn_classic_project(folder_path: &Path, params: &PrepareParams) -> Result<Vec<u8>, Error> {
    // Otherwise Yarn 1 will pack the .yarn directory :(
    folder_path
        .with_join_str(".npmignore")
        .fs_append("/.yarn\n")?;

    let default_yarn
        = zpm_switch::get_latest_stable_version(Some("classic"))
            .await
            .map_err(|_| Error::FailedToRetrieveLatestClassicVersion)?
            .to_file_string();

    ScriptEnvironment::new()?
        .with_cwd(folder_path.clone())
        .with_env_variable("YARNSW_DEFAULT", &default_yarn)

        // Remove environment variables that limit the install to just production dependencies
        .delete_env_variable("NODE_ENV")

        .run_exec("yarn", vec!["install"])
        .await
        .ok()?;

    let pack_path = folder_path
        .with_join_str("package.tgz");
    
    let pack_args = match &params.workspace {
        Some(workspace) => vec!["workspace", workspace.as_str(), "pack", "--filename", pack_path.as_str()],
        None => vec!["pack", "--filename", pack_path.as_str()],
    };

    ScriptEnvironment::new()?
        .with_cwd(folder_path.clone())
        .with_env_variable("YARNSW_DEFAULT", &default_yarn)
        .run_exec("yarn", pack_args)
        .await
        .ok()?;

    let pack_tgz
        = pack_path.fs_read()?;
    
    Ok(pack_tgz)
}

async fn prepare_yarn_modern_project(folder_path: &Path, params: &PrepareParams) -> Result<Vec<u8>, Error> {
    // If a lockfile doesn't exist we create a empty one to
    // prevent the project root detection from thinking it's in an
    // undeclared workspace when the user has a lockfile in their home
    // directory on Windows
    let lockfile_path = folder_path
        .with_join_str("yarn.lock");

    if !lockfile_path.fs_exists() {
        lockfile_path.fs_write(b"")?;
    }

    let default_yarn
        = zpm_switch::get_latest_stable_version(Some("berry"))
            .await
            .map_err(|_| Error::FailedToRetrieveLatestClassicVersion)?
            .to_file_string();

    let pack_path = folder_path
        .with_join_str("package.tgz");

    let pack_args = match &params.workspace {
        Some(workspace_name) =>
            vec!["workspace", workspace_name.as_str(), "pack", "--install-if-needed", "--filename", pack_path.as_str()],
        None =>
            vec!["pack", "--install-if-needed", "--filename", pack_path.as_str()],
    };

    ScriptEnvironment::new()?
        .with_cwd(folder_path.clone())
        .with_standard_binaries()

        // We enable inline builds, because nobody wants to
        // read a logfile telling them to open another logfile
        .with_env_variable("YARN_ENABLE_INLINE_BUILDS", "1")
        .with_env_variable("YARNSW_DEFAULT", &default_yarn)

        .run_exec("yarn", pack_args)
        .await
        .ok()?;

    let pack_tgz = pack_path
        .fs_read()?;

    Ok(pack_tgz)
}

async fn prepare_pnpm_project(folder_path: &Path, _params: &PrepareParams) -> Result<Vec<u8>, Error> {
    ScriptEnvironment::new()?
        .with_cwd(folder_path.clone())
        .run_exec("pnpm", vec!["install"])
        .await
        .ok()?;

    let pack_result = ScriptEnvironment::new()?
        .with_cwd(folder_path.clone())
        .run_exec("pnpm", vec!["pack"])
        .await
        .ok()?;

    let pack_file
        = String::from_utf8(pack_result.output().stdout.clone())?;

    let pack_tgz = folder_path
        .with_join_str(pack_file.trim())
        .fs_read()?;

    Ok(pack_tgz)
}

async fn prepare_yarn_zpm_project(folder_path: &Path, params: &PrepareParams) -> Result<Vec<u8>, Error> {
    let cwd_path = params.cwd.as_ref()
        .map(|cwd| folder_path.with_join_str(cwd))
        .unwrap_or(folder_path.clone());

    let archive_path = folder_path
        .with_join_str("archive.tgz");

    let mut pack_args = vec![];

    if let Some(workspace) = &params.workspace {
        pack_args.push("workspace");
        pack_args.push(workspace.as_str());
    }

    pack_args.push("pack");
    pack_args.push("--install-if-needed");
    pack_args.push("--out");
    pack_args.push(archive_path.as_str());

    ScriptEnvironment::new()?
        .with_cwd(cwd_path.clone())
        .run_exec("yarn", pack_args)
        .await
        .ok()?;

    let pack_tgz = archive_path
        .fs_read()?;

    Ok(pack_tgz)
}
